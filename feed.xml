<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Nanoc</title>
    <link href="https://blog.nanoc.work/feed.xml" rel="self" />
    <link href="https://blog.nanoc.work" />
    <updated>2022-02-05T20:05:40+08:00</updated>
    <author>
        <name>Nanoc</name>
    </author>
    <id>https://blog.nanoc.work</id>

    <entry>
        <title>Python-request&amp;beautifulsoup爬虫使用方法速记</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/python-requestandbeautifulsouppa-chong-shi-yong-fang-fa-su-ji/"/>
        <id>https://blog.nanoc.work/python-requestandbeautifulsouppa-chong-shi-yong-fang-fa-su-ji/</id>
            <category term="Python"/>

        <updated>2022-02-05T20:05:40+08:00</updated>
            <summary>
                <![CDATA[
                    Python-request&amp;beautifulsoup爬虫使用方法速记 简单记录request&amp;bs4使用方法。 import requests # 浏览器头 headers = { &#39;user_agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#39; } # 传参 params = {} params[&#39;email&#39;] = userName[number] params[&#39;passwd&#39;] = userPasswd[number] # 发送request get请求 response = requests.get(url=url, params=params, headers=headers) # 发送request post请求 response&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="python-requestbeautifulsoup爬虫使用方法速记">Python-request&amp;beautifulsoup爬虫使用方法速记</h2>
<p>简单记录request&amp;bs4使用方法。</p>
<h2 id="request">request</h2>
<pre><code class="language-python">import requests
# 浏览器头
headers = {
    &#39;user_agent&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#39;
}
# 传参
params = {}
params[&#39;email&#39;] = userName[number]
params[&#39;passwd&#39;] = userPasswd[number]
# 发送request get请求
response = requests.get(url=url, params=params, headers=headers)
# 发送request post请求
response = requests.post(url=url, params=params, headers=headers)
</code></pre>
<pre><code class="language-python">headers = {
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64)&#39;
    &#39; AppleWebKit/537.36(KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#39;,
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
}
</code></pre>
<h2 id="beautifulsoup">beautifulsoup</h2>
<pre><code class="language-python">from bs4 import BeautifulSoup

#-----
# 解析|
#-----
# 发起请求
response = requests.get(url, headers=headers)
# 指定编码
response.encoding = &#39;utf-8&#39;
soup = BeautifulSoup(response.text)
# 使用lxml解析
soup = BeautifulSoup(html, &#39;lxml&#39;)

#--------
# 元素选择| # 使用selector,返回list
#--------
# 选择指定元素一次
soup = soup.select_one(&quot;a&quot;)
# 选择全部指定元素
soup = soup.select(&quot;a&quot;)
# 选择全部指定元素
soup = soup.find_all(&quot;a&quot;)
# 按照属性查找
soup = soup.select_one(&#39;p [href=&quot;http://example.com/tillie&quot;]&#39;)
# 通过 id 名查找
soup.select_one(&#39;#ID&#39;)
# 通过类名查找
soup.select_one(&#39;.sister&#39;)
#循环
for i in soup:
    print(i.text)

#--------
# 获取属性|
#--------
list[0].get(&#39;href&#39;)


#--------
# Xpath|
#--------
demo = selector.xpath(&#39;&#39;)
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Python进行Base64解码</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/pythonjin-xing-base64jie-ma/"/>
        <id>https://blog.nanoc.work/pythonjin-xing-base64jie-ma/</id>
            <category term="Python"/>

        <updated>2022-02-05T20:05:17+08:00</updated>
            <summary>
                <![CDATA[
                    Python进行Base64解码 使用base64进行解码 import base64 message = &quot;Hello&quot; # 返回字节对象 a = bytes(message, &#39;utf-8&#39;) print(a) # Base64编码 b = base64.b64encode(a) print(b) # Base64解码并.decode(&#39;utf-8&#39;)去掉b&#39;&#39; c = base64.b64decode(b).decode(&#39;utf-8&#39;) print(c) 
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="python进行base64解码">Python进行Base64解码</h2>
<p>使用base64进行解码</p>
<pre><code class="language-python">import base64

message = &quot;Hello&quot;
# 返回字节对象
a = bytes(message, &#39;utf-8&#39;)
print(a)
# Base64编码
b = base64.b64encode(a)
print(b)
# Base64解码并.decode(&#39;utf-8&#39;)去掉b&#39;&#39;
c = base64.b64decode(b).decode(&#39;utf-8&#39;)
print(c)
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Python Multiprocessing用法简单速记</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/python-multiprocessingyong-fa-jian-dan-su-ji/"/>
        <id>https://blog.nanoc.work/python-multiprocessingyong-fa-jian-dan-su-ji/</id>
            <category term="Python"/>

        <updated>2022-02-05T20:04:59+08:00</updated>
            <summary>
                <![CDATA[
                    Python Multiprocessing用法简单速记 使用Multiprocessing进行简单多进程。 from multiprocessing import Pool import time import random def toPool(todo): newarr = [] for i in range(1000): newarr.append(random.random()*10) newarr.sort() if __name__ == &quot;__main__&quot;: start_time = time.time() arr = [] for i in range(10000): arr.append(i) for i in arr: newarr = [] for&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="python-multiprocessing用法简单速记">Python Multiprocessing用法简单速记</h2>
<p>使用Multiprocessing进行简单多进程。</p>
<pre><code class="language-python">from multiprocessing import Pool
import time
import random

def toPool(todo):
    newarr = []
    for i in range(1000):
        newarr.append(random.random()*10)
        newarr.sort()


if __name__ == &quot;__main__&quot;:
    start_time = time.time()
    arr = []
    for i in range(10000):
        arr.append(i)
    for i in arr:
        newarr = []
        for i in range(1000):
            newarr.append(random.random()*10)
            newarr.sort()
    end_time = time.time()
    use_time = end_time - start_time
    print(&quot;first:&quot;+ str(use_time))
    # 多进程
    start_time = time.time()
    arr = []
    for i in range(10000):
        arr.append(i)
    pool = Pool(processes=4)
    pool.map(toPool, arr)
    pool.close()
    pool.join()
    end_time = time.time()
    use_time = end_time - start_time
    print(&quot;second:&quot;+ str(use_time))
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Python 文件读写操作</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/python-wen-jian-du-xie-cao-zuo/"/>
        <id>https://blog.nanoc.work/python-wen-jian-du-xie-cao-zuo/</id>
            <category term="Python"/>

        <updated>2022-02-05T20:04:42+08:00</updated>
            <summary>
                <![CDATA[
                    读写模式 值 描述 r 读模式 w 写模式 a 追加模式 b 二进制模式（可追加到其他模式中） + 读/写模式（可追加到其他模式中 # 追加读写模式 自动创建文件 f = open(&quot;demo.txt&quot;, &#39;a+&#39;, encoding=&quot;utf-8&quot;) f.write(soup.text) f.close() # 覆盖 自动创建文件 f = open(&quot;C:/Users/Inokoe/Desktop/demo.txt&quot;, &#39;w&#39;, encoding=&quot;utf-8&quot;) f.write(&#39;653&#39;) f.close() f = open(&quot;C:/Users/Inokoe/Desktop/demo.txt&quot;, &#39;w+&#39;, encoding=&quot;utf-8&quot;) f.write(&#39;653&#39;) # 定位到开头可以正常读取 f.seek(0) print(f.read()) f.close() #&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="读写模式">读写模式</h2>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>读模式</td>
</tr>
<tr>
<td>w</td>
<td>写模式</td>
</tr>
<tr>
<td>a</td>
<td>追加模式</td>
</tr>
<tr>
<td>b</td>
<td>二进制模式（可追加到其他模式中）</td>
</tr>
<tr>
<td>+</td>
<td>读/写模式（可追加到其他模式中</td>
</tr>
</tbody></table>
<pre><code class="language-python"># 追加读写模式 自动创建文件
f = open(&quot;demo.txt&quot;, &#39;a+&#39;, encoding=&quot;utf-8&quot;)
f.write(soup.text)
f.close()

# 覆盖 自动创建文件
f = open(&quot;C:/Users/Inokoe/Desktop/demo.txt&quot;, &#39;w&#39;, encoding=&quot;utf-8&quot;)
f.write(&#39;653&#39;) 
f.close()

f = open(&quot;C:/Users/Inokoe/Desktop/demo.txt&quot;, &#39;w+&#39;, encoding=&quot;utf-8&quot;)
f.write(&#39;653&#39;) 
# 定位到开头可以正常读取
f.seek(0)
print(f.read())
f.close()

# 只读
f = open(&quot;C:/Users/Inokoe/Desktop/demo.txt&quot;, &#39;r&#39;, encoding=&quot;utf-8&quot;)
f.write(&#39;653&#39;) 
f.close()
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Cpp 利用stringstream转换字符</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/cpp-li-yong-stringstreamzhuan-huan-zi-fu/"/>
        <id>https://blog.nanoc.work/cpp-li-yong-stringstreamzhuan-huan-zi-fu/</id>
            <category term="C++"/>

        <updated>2022-02-05T20:04:19+08:00</updated>
            <summary>
                <![CDATA[
                    stringstream stringstream是包含在中的，其中定义了三个类：istringstream、ostringstream 和 stringstream，分别用来进行流的输入、输出和输入输出操作。 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { stringstream sts; string x = &quot;10&quot;; int z = 100; string y = &quot;&quot;; //string 给 string sts&lt;&lt;x; y = sts.str(); cout&lt;&lt;y&lt;&lt;endl; //清除缓冲区 /* 在多次数据类型转换的场景下，必须使用 clear() 方法清空 stringstream，不使用 clear()方法或使用 str(&quot;&quot;) 方法，都不能得到数据类型转换的正确结果。 */ sts.str(&quot;&quot;);&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="stringstream">stringstream</h2>
<blockquote>
<p>stringstream是包含在<sstream>中的，其中定义了三个类：istringstream、ostringstream 和 stringstream，分别用来进行流的输入、输出和输入输出操作。</p>
</blockquote>
<h2 id="用法">用法</h2>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
    stringstream sts;
    string x = &quot;10&quot;; 
    int z = 100;
    string y = &quot;&quot;;

    //string 给 string
    sts&lt;&lt;x;
    y = sts.str();
    cout&lt;&lt;y&lt;&lt;endl;
    
    //清除缓冲区
    /*
    在多次数据类型转换的场景下，必须使用 clear() 方法清空 stringstream，不使用 clear()方法或使用 str(&quot;&quot;) 方法，都不能得到数据类型转换的正确结果。
    */
    sts.str(&quot;&quot;);
    sts.clear();

    //int 给 string
    sts&lt;&lt;z;
    x = sts.str();
    cout&lt;&lt;x&lt;&lt;endl;

    return 0;
}
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>C++ STL next_permutation</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/c-stl-next_permutation/"/>
        <id>https://blog.nanoc.work/c-stl-next_permutation/</id>
            <category term="C++"/>

        <updated>2022-02-05T20:04:00+08:00</updated>
            <summary>
                <![CDATA[
                    字典序全排列 举例 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int a[4]={1,2,3,4}; sort(a,a+4); //数组元素顺序将被改变，直到无法继续排序 do{ cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[1]&lt;&lt;&quot; &quot;&lt;&lt;a[2]&lt;&lt;&quot; &quot;&lt;&lt;a[3]&lt;&lt;endl; }while(next_permutation(a,a+4)); return 0; } 找到第99个排列序 #include &lt;bits/stdc++.h&gt; using namespace std; int a[7]={1,2,3,4,5,6,7}; int n=0; int main() { sort(a,a+7); do{ if(n==99){ for(int i=0;i&lt;7;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;; cout&lt;&lt;endl; break; }&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="字典序全排列">字典序全排列</h2>
<p>举例</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
    int a[4]={1,2,3,4};
    sort(a,a+4);
    //数组元素顺序将被改变，直到无法继续排序
    do{
        cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[1]&lt;&lt;&quot; &quot;&lt;&lt;a[2]&lt;&lt;&quot; &quot;&lt;&lt;a[3]&lt;&lt;endl;
    }while(next_permutation(a,a+4));
    return 0;
}
</code></pre>
<p>找到第99个排列序</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[7]={1,2,3,4,5,6,7};
int n=0;
int main() {
    sort(a,a+7); 
    do{
        if(n==99){
            for(int i=0;i&lt;7;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
            cout&lt;&lt;endl;
            break;
        }
        n++;
    }while(next_permutation(a,a+7));

    sort(a,a+7);

    for(int i = 1 ; next_permutation(a,a+7);i++){
        if(i==99){
            for(int i=0;i&lt;7;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
            break;
        }
    }
    return 0;
}
</code></pre>

            ]]>
        </content>
    </entry>
    <entry>
        <title>UCM-UCSI ACPI 状态码 43</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/ucm-ucsi-acpi-zhuang-tai-ma-43/"/>
        <id>https://blog.nanoc.work/ucm-ucsi-acpi-zhuang-tai-ma-43/</id>
            <category term="Windows"/>

        <updated>2022-02-05T20:03:36+08:00</updated>
            <summary>
                <![CDATA[
                    UCM-UCSI ACPI 此驱动用于Windows Type-C 接口相关功能，在设备管理中此驱动出现黄色感叹号，并状态43。 受此影响，电脑可能会出现一些异常，如无法PD充电。 Windows特定的系统版本或补丁以及BIOS更新导致的故障。 重置BIOS，笔记本未插电状态关机，并尽可能长按电源键使其开机，并强制断电以强制BIOS重新设置。 如果不适用此方法，请移至Google进行查询，有很多解决办法，但主要跟特定的机器相关。 
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="ucm-ucsi-acpi">UCM-UCSI ACPI</h2>
<p>此驱动用于Windows Type-C 接口相关功能，在设备管理中此驱动出现黄色感叹号，并状态43。
受此影响，电脑可能会出现一些异常，如无法PD充电。</p>
<h2 id="产生原因">产生原因</h2>
<p>Windows特定的系统版本或补丁以及BIOS更新导致的故障。</p>
<h2 id="解决方法">解决方法</h2>
<p>重置BIOS，笔记本未插电状态关机，并尽可能长按电源键使其开机，并强制断电以强制BIOS重新设置。
如果不适用此方法，请移至Google进行查询，有很多解决办法，但主要跟特定的机器相关。</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>apache强制HTTPS</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/apacheqiang-zhi-https/"/>
        <id>https://blog.nanoc.work/apacheqiang-zhi-https/</id>
            <category term="Apache"/>

        <updated>2022-02-05T20:02:40+08:00</updated>
            <summary>
                <![CDATA[
                    apache强制HTTPS Https已经成为了标配，如无特殊需求，一般需要对80做301重定向到443，即所说的强制Https。 &lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteBase / RewriteCond %{SERVER_PORT} !^443$ RewriteRule (.*) https://%{SERVER_NAME}/$1 [R=301,L] &lt;/IfModule&gt; Apache - Typecho静态化 规则如下： &lt;IfModule mod_rewrite.c&gt; RewriteEngine On # 下面是在根目录，文件夹要修改路径 RewriteBase / RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ /index.php/$1 [L] &lt;/IfModule&gt; 接着去Typecho后台也开启静态化。 有多种规则写法 
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="apache强制https">apache强制HTTPS</h2>
<p>Https已经成为了标配，如无特殊需求，一般需要对80做301重定向到443，即所说的强制Https。</p>
<pre><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteBase /
RewriteCond %{SERVER_PORT} !^443$
RewriteRule (.*) https://%{SERVER_NAME}/$1 [R=301,L]
&lt;/IfModule&gt;
</code></pre>
<h2 id="apache---typecho静态化">Apache - Typecho静态化</h2>
<p>规则如下：</p>
<pre><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine On
# 下面是在根目录，文件夹要修改路径
RewriteBase /
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ /index.php/$1 [L]
&lt;/IfModule&gt;
</code></pre>
<p>接着去Typecho后台也开启静态化。</p>
<h2 id="注意">注意</h2>
<p>有多种规则写法</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>C++判断是否为数字或字母</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/cpan-duan-shi-fou-wei-shu-zi-huo-zi-mu/"/>
        <id>https://blog.nanoc.work/cpan-duan-shi-fou-wei-shu-zi-huo-zi-mu/</id>
            <category term="C++"/>

        <updated>2022-02-05T20:02:09+08:00</updated>
            <summary>
                <![CDATA[
                    声明头文件 cctype（字符处理库）中定义了有关字符判断与处理的库函数。 # include &lt;cctype&gt; 相关函数 函数 描述 isalnum(char) 当c是字母或者数字时为真 isalpha(char) 当c是字母时为真 iscntrl(char) 当c是控制字符时为真 isdigit(char) 当c是数字时为真 isgraph(char) 当c不是空格但可打印时为真 islower(char) 当c是小写字母时为真 isprint(char) 当c是可打印字符时为真 ispunct(char) 当c是标点符号时为真 isspace(char) 当c是空白时为真 isupper(char) 当c是大写字母时为真 isxdigit(char) 当c是十六进制时为真 字符转换函数 函数 描述 tolower 将字母转换为小写返回 toupper 将字母转换为大写返回 注意 其中： -isalnum()用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于az||AZ||0~9 -isalpha遇到大写字母输出1，遇到小写输出2 #include &lt;bits/stdc++.h&gt; using namespace&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="声明头文件">声明头文件</h2>
<p>cctype（字符处理库）中定义了有关字符判断与处理的库函数。</p>
<pre><code class="language-cpp"># include &lt;cctype&gt;
</code></pre>
<h2 id="相关函数">相关函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum(char)</td>
<td>当c是字母或者数字时为真</td>
</tr>
<tr>
<td>isalpha(char)</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td>iscntrl(char)</td>
<td>当c是控制字符时为真</td>
</tr>
<tr>
<td>isdigit(char)</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td>isgraph(char)</td>
<td>当c不是空格但可打印时为真</td>
</tr>
<tr>
<td>islower(char)</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td>isprint(char)</td>
<td>当c是可打印字符时为真</td>
</tr>
<tr>
<td>ispunct(char)</td>
<td>当c是标点符号时为真</td>
</tr>
<tr>
<td>isspace(char)</td>
<td>当c是空白时为真</td>
</tr>
<tr>
<td>isupper(char)</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td>isxdigit(char)</td>
<td>当c是十六进制时为真</td>
</tr>
</tbody></table>
<h2 id="字符转换函数">字符转换函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tolower</td>
<td>将字母转换为小写返回</td>
</tr>
<tr>
<td>toupper</td>
<td>将字母转换为大写返回</td>
</tr>
</tbody></table>
<h2 id="注意">注意</h2>
<p>其中：
-isalnum()用来判断一个字符是否为数字或者字母，也就是说判断一个字符是否属于a<del>z||A</del>Z||0~9
-isalpha遇到大写字母输出1，遇到小写输出2</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    cout&lt;&lt;isalpha(&#39;N&#39;)&lt;&lt;endl; //输出1
    cout&lt;&lt;isalpha(&#39;n&#39;)&lt;&lt;endl; //输出2
    return 0;
}
</code></pre>
<h2 id="参考">参考</h2>
<blockquote>
<p><a href="https://blog.csdn.net/gyysmall/article/details/12650937">https://blog.csdn.net/gyysmall/article/details/12650937</a>
<a href="https://blog.csdn.net/q302989778/article/details/90215213">https://blog.csdn.net/q302989778/article/details/90215213</a>
<a href="https://www.cnblogs.com/r1-12king/p/13161762.html">https://www.cnblogs.com/r1-12king/p/13161762.html</a></p>
</blockquote>

            ]]>
        </content>
    </entry>
    <entry>
        <title>scanf()的用法专辑</title>
        <author>
            <name>Nanoc</name>
        </author>
        <link href="https://blog.nanoc.work/scanfde-yong-fa-zhuan-ji/"/>
        <id>https://blog.nanoc.work/scanfde-yong-fa-zhuan-ji/</id>
            <category term="C"/>

        <updated>2022-02-05T20:01:30+08:00</updated>
            <summary>
                <![CDATA[
                    C 库函数 - scanf scanf是格式输入函数，在使用scanf函数时要加上#include &lt;stdio.h&gt;，简单记录下基本用法。 输入输出例子 //输入int:int scanf(&quot;%d:%d&quot;,&amp;a,&amp;b); //输入字符串 char str[20]; printf(&quot;请输入一串字符: &quot;); scanf(&quot;%s&quot;, str); printf(&quot;这个字符串为: %s\n&quot;, str); 进制输入输出 /* 使用scanf和printf处理八进制、十进制和十六进制整数 */ #include &lt;stdio.h&gt; int main(void) { int int_dec, int_hex, int_oct; int constant = 74; /* 用三种进制形式给整型变量赋值 */ scanf(&quot;%d&quot;, &amp;int_dec); /* 10 */ scanf(&quot;%x&quot;,&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2 id="c-库函数---scanf">C 库函数 - scanf</h2>
<p>scanf是格式输入函数，在使用scanf函数时要加上#include &lt;stdio.h&gt;，简单记录下基本用法。</p>
<h2 id="scanf-类型说明符：">scanf 类型说明符：</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>合格的输入</th>
<th>参数的类型</th>
</tr>
</thead>
<tbody><tr>
<td>%a、%A</td>
<td>读入一个浮点值(仅 C99 有效)。</td>
<td>float *</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>
<td>char *</td>
</tr>
<tr>
<td>%d</td>
<td>十进制整数：数字前面的 + 或 - 号是可选的。</td>
<td>int *</td>
</tr>
<tr>
<td>%e、%E、%f、%F、%g、%G</td>
<td>浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td>
<td>float *</td>
</tr>
<tr>
<td>%lf</td>
<td>%lf代表双精度浮点型数据（double）。</td>
<td>double *</td>
</tr>
<tr>
<td>%i</td>
<td>读入十进制，八进制，十六进制整数 。</td>
<td>int *</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数。</td>
<td>int *</td>
</tr>
<tr>
<td>%s</td>
<td>字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>
<td>char *</td>
</tr>
<tr>
<td>%u</td>
<td>无符号的十进制整数。</td>
<td>unsigned int *</td>
</tr>
<tr>
<td>%x、%X</td>
<td>十六进制整数。</td>
<td>int *</td>
</tr>
<tr>
<td>%p</td>
<td>读入一个指针 。</td>
<td></td>
</tr>
<tr>
<td>%[]</td>
<td>扫描字符集合 。</td>
<td></td>
</tr>
<tr>
<td>%%</td>
<td>读 % 符号。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="实例">实例</h2>
<p>输入输出例子</p>
<pre><code class="language-c">//输入int:int
scanf(&quot;%d:%d&quot;,&amp;a,&amp;b);

//输入字符串
char str[20];
printf(&quot;请输入一串字符: &quot;);
scanf(&quot;%s&quot;, str);
printf(&quot;这个字符串为:   %s\n&quot;, str);
</code></pre>
<p>进制输入输出</p>
<pre><code class="language-c">/* 使用scanf和printf处理八进制、十进制和十六进制整数 */
#include &lt;stdio.h&gt;
 
int main(void) {
    int int_dec, int_hex, int_oct;
    int constant = 74;
 
    /* 用三种进制形式给整型变量赋值 */
    scanf(&quot;%d&quot;, &amp;int_dec); /* 10 */
    scanf(&quot;%x&quot;, &amp;int_hex); /* 16 */
    scanf(&quot;%o&quot;, &amp;int_oct); /* 8 */
 
    /* 用十进制的形式打印三个变量 */
    printf(&quot;int_dec(11) = %d\n&quot;, int_dec); /* 第14行 */
    printf(&quot;int_hex(11) = %d\n&quot;, int_hex); /* 第15行 */
    printf(&quot;int_oct(11) = %d\n&quot;, int_oct); /* 第16行 */
 
    /* 把十进制的74用三种进制分别打印 */
    printf(&quot;(Dec)74 = %d\n&quot;, constant);
    printf(&quot;(Hex)74 = %x\n&quot;, constant);
    printf(&quot;(HeX)74 = %X\n&quot;, constant); /* 输出格式为大写 */
    printf(&quot;(Oct)74 = %o\n&quot;, constant);
 
    return 0;
}
//Demo Source: http://yuncode.net/code/c_50b44383d3adc52
</code></pre>

            ]]>
        </content>
    </entry>
</feed>
